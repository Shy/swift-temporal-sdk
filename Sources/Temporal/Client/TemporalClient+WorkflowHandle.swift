//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Temporal SDK open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift Temporal SDK project authors
// Licensed under MIT License
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift Temporal SDK project authors
//
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

extension TemporalClient {
    // MARK: - Start Workflow

    /// Starts a workflow execution and returns a handle for managing the workflow instance.
    ///
    /// This method initiates a new workflow execution on the Temporal cluster and immediately returns a handle
    /// that can be used to monitor, query, signal, or wait for the workflow's completion.
    ///
    /// The returned handle provides access to the workflow's result through ``WorkflowHandle/result(followRuns:callOptions:)`` and
    /// supports various control operations like signaling and querying. The handle's ``WorkflowHandle/runID``
    /// is not set by this method; use ``workflowHandle(type:id:runID:firstExecutionRunID:)`` if you need to
    /// specify a particular run ID.
    ///
    /// ## Run ID Behavior
    ///
    /// The run ID generated by the Temporal server is available in both ``WorkflowHandle/resultRunID`` and
    /// ``WorkflowHandle/firstExecutionRunID`` properties of the returned handle. This run ID uniquely
    /// identifies this specific execution attempt of the workflow.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow.
    /// - Returns: A ``WorkflowHandle`` for monitoring and controlling the started workflow.
    /// - Throws: An error if the workflow cannot be started due to validation failures or server issues.
    public func startWorkflow<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        options: WorkflowOptions,
        input: Workflow.Input,
    ) async throws -> WorkflowHandle<Workflow> {
        let untypedHandle = try await self.startWorkflow(
            name: type.name,
            options: options,
            input: input
        )

        // TODO: Once `StartSignal` as a `WorkflowOptions` is supported, set `resultRunID` to signal run ID and don't set `firstExecutionRunID`
        return WorkflowHandle<Workflow>(
            untypedHandle: untypedHandle
        )
    }

    /// Starts a workflow execution with no input and returns a handle for managing the workflow instance.
    ///
    /// This convenience method starts a workflow that requires no input parameters. It provides the same
    /// functionality as ``startWorkflow(type:options:input:)`` but is specifically designed for workflows
    /// that have `Void` as their input type.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    /// - Returns: A ``WorkflowHandle`` for monitoring and controlling the started workflow.
    /// - Throws: An error if the workflow cannot be started due to validation failures or server issues.
    public func startWorkflow<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        options: WorkflowOptions
    ) async throws -> WorkflowHandle<Workflow> where Workflow.Input == Void {
        try await self.startWorkflow(type: type, options: options, input: ())
    }

    // MARK: - Start Workflow and get result

    /// Executes a workflow and waits for its completion, returning the result.
    ///
    /// This method provides a convenient way to start a workflow and wait for its completion in a single call.
    /// It combines the functionality of ``startWorkflow(type:options:input:)`` and ``WorkflowHandle/result(followRuns:callOptions:)``
    /// into one operation.
    ///
    /// The method suspends until the workflow completes successfully, fails, or is terminated. For long-running
    /// workflows, consider using ``startWorkflow(type:options:input:)`` instead to get immediate access to
    /// the workflow handle for monitoring and control operations.
    ///
    /// This approach is ideal for workflows that complete quickly or when you only need the final result
    /// without intermediate monitoring or control.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow's run method.
    /// - Returns: The output value produced by the completed workflow execution.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        options: WorkflowOptions,
        input: Workflow.Input,
    ) async throws -> Workflow.Output {
        try await self.startWorkflow(
            type: type,
            options: options,
            input: input
        ).result()
    }

    /// Executes a workflow with no input and waits for its completion, returning the result.
    ///
    /// This convenience method combines workflow starting and result waiting for workflows that require no input.
    /// It provides the same functionality as ``executeWorkflow(type:options:input:)->_`` but is specifically
    /// designed for workflows with `Void` input type.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    /// - Returns: The output value produced by the completed workflow execution.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        options: WorkflowOptions,
    ) async throws -> Workflow.Output where Workflow.Input == Void {
        try await self.startWorkflow(
            type: type,
            options: options,
            input: ()
        ).result()
    }

    /// Executes a workflow and waits for its completion without returning a result.
    ///
    /// This convenience method combines workflow starting and result waiting for workflows that produce no output.
    /// It provides the same functionality as ``executeWorkflow(type:options:input:)`` but is specifically
    /// designed for workflows with `Void` output type.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow's run method.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        options: WorkflowOptions,
        input: Workflow.Input,
    ) async throws where Workflow.Output == Void {
        try await self.startWorkflow(
            type: type,
            options: options,
            input: input
        ).result()
    }

    // MARK: - Get Workflow Handle

    /// Creates a handle for accessing and managing an existing workflow execution.
    ///
    /// This method creates a handle for an already-running or completed workflow execution without starting
    /// a new workflow. Use this when you have the workflow ID and want to interact with an existing workflow
    /// instance through queries, signals, or to wait for its completion.
    ///
    /// Unlike handles returned by ``startWorkflow(type:options:input:)``, this method allows you to specify
    /// the exact run ID you want to target. This is useful when you need to interact with a specific
    /// execution attempt of a workflow that may have been retried or continued as a new execution.
    ///
    /// ## Run ID Configuration
    ///
    /// This method sets both ``WorkflowHandle/runID`` and ``WorkflowHandle/firstExecutionRunID`` based on
    /// the provided parameters. The ``WorkflowHandle/resultRunID`` is set to `nil` since no new execution
    /// is being started.
    ///
    /// - Parameters:
    ///   - type: The workflow type that defines the expected business logic.
    ///   - id: The unique identifier of the workflow execution.
    ///   - runID: Run ID of the specific workflow execution or `nil` for the latest execution.
    ///   - firstExecutionRunID: The run ID of the first execution in the workflow chain, used for
    ///   cancellation and termination operations.
    /// - Returns: A ``WorkflowHandle`` configured for the specified workflow execution.
    public func workflowHandle<Workflow: WorkflowDefinition>(
        type: Workflow.Type = Workflow.self,
        id: String,
        runID: String? = nil,
        firstExecutionRunID: String? = nil
    ) -> WorkflowHandle<Workflow> {
        WorkflowHandle<Workflow>(
            untypedHandle: UntypedWorkflowHandle(
                interceptor: self.interceptor,
                id: id,
                runID: runID,
                resultRunID: nil,  // `resultRunID` is not set
                firstExecutionRunID: firstExecutionRunID
            )
        )
    }

    // TODO: Possibly support `StartUpdateWithStartWorkflow`
    // Start an update using its name, possibly starting the workflow at the same time.
    // Also add interceptors.
}
